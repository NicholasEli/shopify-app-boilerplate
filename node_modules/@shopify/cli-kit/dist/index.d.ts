import { Listr, ListrTaskWrapper, ListrDefaultRenderer, ListrTask } from 'listr2';
import { ExecaChildProcess } from 'execa';
import { Writable } from 'node:stream';
import { camelCase, paramCase, snakeCase } from 'change-case';
import * as pathe from 'pathe';
import { findUp } from 'find-up';
import fastGlob from 'fast-glob';
import * as simple_git from 'simple-git';
import { platform } from 'node:process';
import { z } from 'zod';
import Conf from 'conf';
import nodeFetch, { RequestInfo, RequestInit } from 'node-fetch';
import semver$1 from 'semver/classes/semver';
import coerce from 'semver/functions/coerce';

function _mergeNamespaces(n, m) {
  m.forEach(function (e) {
    e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
      if (k !== 'default' && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  });
  return Object.freeze(n);
}

interface Question {
    type: 'input' | 'select';
    name: string;
    message: string;
    validate?: (value: string) => string | boolean;
    default?: string;
    choices?: string[] | {
        name: string;
        value: string;
    }[];
    result?: (value: string) => string | boolean;
}
declare const prompt: <T>(questions: Question[]) => Promise<T>;

type ui_Question = Question;
declare const ui_prompt: typeof prompt;
declare const ui_Listr: typeof Listr;
declare const ui_ListrTaskWrapper: typeof ListrTaskWrapper;
declare const ui_ListrDefaultRenderer: typeof ListrDefaultRenderer;
declare const ui_ListrTask: typeof ListrTask;
declare namespace ui {
  export {
    ui_Question as Question,
    ui_prompt as prompt,
    ui_Listr as Listr,
    ui_ListrTaskWrapper as ListrTaskWrapper,
    ui_ListrDefaultRenderer as ListrDefaultRenderer,
    ui_ListrTask as ListrTask,
  };
}

/**
 * A fatal error represents an error shouldn't be rescued and that causes the execution to terminate.
 * There shouldn't be code that catches fatal errors.
 */
declare class Fatal extends Error {
    tryMessage: string | null;
    constructor(message: string, tryMessage?: string | null);
}
/**
 * An abort error is a fatal error that shouldn't be reported as a bug.
 * Those usually represent unexpected scenarios that we can't handle and that usually require some action from the developer
 */
declare class Abort extends Fatal {
}
declare class AbortSilent extends Fatal {
    constructor();
}
/**
 * A bug error is an error that represents a bug and therefore should be reported.
 */
declare class Bug extends Fatal {
}
/**
 * A function that handles errors that blow up in the CLI.
 * @param error Error to be handled.
 * @returns A promise that resolves with the error passed.
 */
declare function handler(error: Error): Promise<Error>;
declare function mapper(error: Error): Promise<Error>;

type error$1_Fatal = Fatal;
declare const error$1_Fatal: typeof Fatal;
type error$1_Abort = Abort;
declare const error$1_Abort: typeof Abort;
type error$1_AbortSilent = AbortSilent;
declare const error$1_AbortSilent: typeof AbortSilent;
type error$1_Bug = Bug;
declare const error$1_Bug: typeof Bug;
declare const error$1_handler: typeof handler;
declare const error$1_mapper: typeof mapper;
declare namespace error$1 {
  export {
    error$1_Fatal as Fatal,
    error$1_Abort as Abort,
    error$1_AbortSilent as AbortSilent,
    error$1_Bug as Bug,
    error$1_handler as handler,
    error$1_mapper as mapper,
  };
}

interface ExecOptions {
    cwd?: string;
    env?: any;
    stdout?: Writable;
    stderr?: Writable;
    stdin?: string;
    signal?: AbortSignal;
}
declare const open: (url: string) => Promise<void>;
/**
 * Runs a command asynchronously, aggregates the stdout data, and returns it.
 * @param command {string} Command to be executed.
 * @param args {string[]} Arguments to pass to the command.
 * @returns A promise that resolves with the aggregatted stdout of the command.
 */
declare const captureOutput: (command: string, args: string[]) => Promise<string>;
declare const exec: (command: string, args: string[], options?: ExecOptions | undefined) => ExecaChildProcess<string>;
interface ConcurrentExecCommand {
    prefix: string;
    executable: string;
    args: string[];
    cwd: string;
}
/**
 * Runs commands concurrently and combines the standard output and error data
 * into a single stream that differenciates the sources using a colored prefix:
 *
 * Example:
 *   [my-extension] Log coming from my-extension
 *   [my-script] Log coming from my script
 *
 * If one of the processes fails, it aborts the running ones and exits with that error.
 * @param commands {ConcurrentExecCommand[]} Commands to execute.
 */
declare const concurrentExec: (commands: ConcurrentExecCommand[]) => Promise<void>;

type system_ExecOptions = ExecOptions;
declare const system_open: typeof open;
declare const system_captureOutput: typeof captureOutput;
declare const system_exec: typeof exec;
declare const system_concurrentExec: typeof concurrentExec;
declare namespace system {
  export {
    system_ExecOptions as ExecOptions,
    system_open as open,
    system_captureOutput as captureOutput,
    system_exec as exec,
    system_concurrentExec as concurrentExec,
  };
}

declare function create$1(templateContent: string): (data: object) => Promise<string>;
/**
 * Given a directory, it traverses the files and directories recursively
 * and replaces variables in directory and file names, and files' content
 * using the Liquid template engine.
 * Files indicate that they are liquid template by using the .liquid extension.
 * @param from {string} Directory that contains the template.
 * @param to {string} Output directory.
 * @param data {string} Data to feed the template engine.
 */
declare function recursiveDirectoryCopy(from: string, to: string, data: any): Promise<void>;

declare const template_recursiveDirectoryCopy: typeof recursiveDirectoryCopy;
declare namespace template {
  export {
    create$1 as create,
    template_recursiveDirectoryCopy as recursiveDirectoryCopy,
  };
}

/** Returns a random string */
declare function randomHex(size: number): string;
declare function generateRandomChallengePair(): {
    codeVerifier: string;
    codeChallenge: string;
};
/**
 * Given a string, it returns it with the first letter capitalized.
 * @param string {string} String whose first letter will be caplitalized.
 * @returns The given string with its first letter capitalized.
 */
declare function capitalize(string: string): string;
/**
 * Given a store, returns a valid store fqdn removing protocol and adding .myshopify.com domain
 * @param store Original store name provided by the user
 * @returns a valid store fqdn
 */
declare function normalizeStoreName(store: string): string;

declare const string_randomHex: typeof randomHex;
declare const string_generateRandomChallengePair: typeof generateRandomChallengePair;
declare const string_capitalize: typeof capitalize;
declare const string_normalizeStoreName: typeof normalizeStoreName;
declare namespace string {
  export {
    string_randomHex as randomHex,
    string_generateRandomChallengePair as generateRandomChallengePair,
    string_capitalize as capitalize,
    string_normalizeStoreName as normalizeStoreName,
    camelCase as camelize,
    paramCase as hyphenize,
    snakeCase as underscore,
  };
}

var path = /*#__PURE__*/_mergeNamespaces({
  __proto__: null,
  findUp: findUp,
  glob: fastGlob
}, [pathe]);

declare function stripUp(path: string, strip: number): string;
/**
 * Creates a temporary directory and ties its lifecycle ot the lifecycle of the callback.
 * @param callback - The callback that receives the temporary directory.
 */
declare function inTemporaryDirectory<T>(callback: (tmpDir: string) => T | Promise<T>): Promise<T>;
/**
 * It reads a file and returns its content as a string using the
 * utf-8 encoding
 * @param path {string} Path to the file to read.
 * @returns {Promise<string>} A promise that resolves with the content of the file.
 */
declare function read(path: string): Promise<string>;
/**
 * Copies a file
 * @param from {string} Path to the directory or file to be copied.
 * @param to {string} Destination path.
 */
declare function copy(from: string, to: string): Promise<void>;
declare function write(path: string, data: string): Promise<void>;
declare function append(path: string, data: string): Promise<void>;
declare function mkdir(path: string): Promise<void>;
declare function remove(path: string): Promise<void>;
declare function rmdir(path: string, { force }?: {
    force?: boolean;
}): Promise<void>;
declare function mkTmpDir(): Promise<string>;
declare function isDirectory(path: string): Promise<boolean>;
/**
 * Moves a file.
 * @param src {string} File to be moved.
 * @param dest {string} Path to be moved to.
 * @param options {object} Moving options.
 */
declare function move(src: string, dest: string, options?: {
    overwrite?: boolean;
}): Promise<void>;
/**
 * Changes the permissions of a directory or file.
 * @param path {string} Path to the file or directory whose permissions will be modified.
 * @param mode {string | numbers} Permissions to set to the file or directory.
 */
declare function chmod(path: string, mode: number | string): Promise<void>;
/**
 * Checks if a file has executable permissions.
 * @param path {string} Path to the file whose permissions will be checked.
 */
declare function hasExecutablePermissions(path: string): Promise<boolean>;
/**
 * Returns true if a file or directory exists
 * @param path {string} Path to the directory or file.
 * @returns {boolean} True if it exists.
 */
declare function exists(path: string): Promise<boolean>;

declare const file_stripUp: typeof stripUp;
declare const file_inTemporaryDirectory: typeof inTemporaryDirectory;
declare const file_read: typeof read;
declare const file_copy: typeof copy;
declare const file_write: typeof write;
declare const file_append: typeof append;
declare const file_mkdir: typeof mkdir;
declare const file_remove: typeof remove;
declare const file_rmdir: typeof rmdir;
declare const file_mkTmpDir: typeof mkTmpDir;
declare const file_isDirectory: typeof isDirectory;
declare const file_move: typeof move;
declare const file_chmod: typeof chmod;
declare const file_hasExecutablePermissions: typeof hasExecutablePermissions;
declare const file_exists: typeof exists;
declare namespace file {
  export {
    file_stripUp as stripUp,
    file_inTemporaryDirectory as inTemporaryDirectory,
    file_read as read,
    file_copy as copy,
    file_write as write,
    file_append as append,
    file_mkdir as mkdir,
    file_remove as remove,
    file_rmdir as rmdir,
    file_mkTmpDir as mkTmpDir,
    file_isDirectory as isDirectory,
    file_move as move,
    file_chmod as chmod,
    file_hasExecutablePermissions as hasExecutablePermissions,
    file_exists as exists,
  };
}

declare const factory: simple_git.SimpleGitFactory;

declare const git_factory: typeof factory;
declare namespace git {
  export {
    git_factory as factory,
  };
}

interface GithubRelease {
    id: number;
    url: string;
    tag_name: string;
    name: string;
    body: string;
    draft: boolean;
    prerelease: boolean;
    created_at: string;
    published_at: string;
    tarball_url: string;
}
interface Options {
    filter: (release: GithubRelease) => boolean;
}
declare function getLatestRelease(user: string, repo: string, { filter }?: Options): Promise<GithubRelease>;
declare function parseRepoUrl(src: string): {
    site: string;
    user: string;
    name: string;
    ref: string;
    subDirectory: string;
    ssh: string;
};

type github_GithubRelease = GithubRelease;
declare const github_getLatestRelease: typeof getLatestRelease;
declare const github_parseRepoUrl: typeof parseRepoUrl;
declare namespace github {
  export {
    github_GithubRelease as GithubRelease,
    github_getLatestRelease as getLatestRelease,
    github_parseRepoUrl as parseRepoUrl,
  };
}

declare enum ContentTokenType {
    Command = 0,
    Path = 1,
    Link = 2,
    Yellow = 3,
    Cyan = 4,
    Magenta = 5,
    Green = 6
}
interface ContentMetadata {
    link?: string;
}
declare class ContentToken {
    type: ContentTokenType;
    value: string;
    metadata: ContentMetadata;
    constructor(value: string, metadata: ContentMetadata | undefined, type: ContentTokenType);
}
declare const token: {
    command: (value: string) => ContentToken;
    path: (value: string) => ContentToken;
    link: (value: string, link: string) => ContentToken;
    cyan: (value: string) => ContentToken;
    yellow: (value: string) => ContentToken;
    magenta: (value: string) => ContentToken;
    green: (value: string) => ContentToken;
};
declare class TokenizedString {
    value: string;
    constructor(value: string);
}
declare type Message = string | TokenizedString;
declare function content(strings: TemplateStringsArray, ...keys: (ContentToken | string)[]): TokenizedString;
/** Log levels */
declare type LogLevel = 'fatal' | 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'silent';
/**
 *
 * @returns {LogLevel} It returns the log level set by the user.
 */
declare const currentLogLevel: () => LogLevel;
declare const shouldOutput: (logLevel: LogLevel) => boolean;
/**
 * Ouputs information to the user. This is akin to "console.log"
 * Info messages don't get additional formatting.
 * Note: Info messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const info: (content: Message) => void;
/**
 * Outputs a success message to the user.
 * Success message receive a special formatting to make them stand out in the console.
 * Note: Success messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const success: (content: Message) => void;
/**
 * Ouputs debug information to the user. By default these output is hidden unless the user calls the CLI with --verbose.
 * Debug messages don't get additional formatting.
 * Note: Debug messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const debug: (content: Message) => void;
/**
 * Outputs a warning message to the user.
 * Warning messages receive a special formatting to make them stand out in the console.
 * Note: Warning messages are sent through the standard output.
 * @param content {string} The content to be output to the user.
 */
declare const warn: (content: Message) => void;
/**
 * Prints a new line in the terminal.
 */
declare const newline: () => void;
/**
 * Formats and outputs a fatal error.
 * Note: This API is not intended to be used internally. If you want to
 * abort the execution due to an error, raise a fatal error and let the
 * error handler handle and format it.
 * @param content {Fatal} The fatal error to be output.
 */
declare const error: (content: Fatal) => Promise<void>;
declare function stringifyMessage(message: Message): string;
interface OutputProcess {
    /** The prefix to include in the logs
     *   [vite] Output coming from Vite
     */
    prefix: string;
    /**
     * A callback to invoke the process. stdout and stderr should be used
     * to send standard output and error data that gets formatted with the
     * right prefix.
     */
    action: (stdout: Writable, stderr: Writable) => Promise<void>;
}
/**
 * Use this function when you have multiple concurrent processes that send data events
 * and we need to output them ensuring that they can visually differenciated by the user.
 *
 * @param processes {OutputProcess[]} A list of processes to run concurrently.
 */
declare function concurrent(processes: OutputProcess[]): Promise<void>;
declare function shouldDisplayColors(): boolean;

declare const output_token: typeof token;
type output_Message = Message;
declare const output_content: typeof content;
type output_LogLevel = LogLevel;
declare const output_currentLogLevel: typeof currentLogLevel;
declare const output_shouldOutput: typeof shouldOutput;
declare const output_info: typeof info;
declare const output_success: typeof success;
declare const output_debug: typeof debug;
declare const output_warn: typeof warn;
declare const output_newline: typeof newline;
declare const output_error: typeof error;
declare const output_stringifyMessage: typeof stringifyMessage;
declare const output_concurrent: typeof concurrent;
declare const output_shouldDisplayColors: typeof shouldDisplayColors;
declare namespace output {
  export {
    output_token as token,
    output_Message as Message,
    output_content as content,
    output_LogLevel as LogLevel,
    output_currentLogLevel as currentLogLevel,
    output_shouldOutput as shouldOutput,
    output_info as info,
    output_success as success,
    output_debug as debug,
    output_warn as warn,
    output_newline as newline,
    output_error as error,
    output_stringifyMessage as stringifyMessage,
    output_concurrent as concurrent,
    output_shouldDisplayColors as shouldDisplayColors,
  };
}

declare enum DependencyManager {
    Npm = "npm",
    Yarn = "yarn",
    Pnpm = "pnpm"
}
declare const dependencyManager: string[];
/**
 * Returns the dependency manager used to run the create workflow.
 * @param env {Object} The environment variables of the process in which the CLI runs.
 * @returns The dependency manager
 */
declare function dependencyManagerUsedForCreating(env?: NodeJS.ProcessEnv): DependencyManager;
/**
 * Installs the dependencies in the given directory.
 * @param directory {string} The directory that contains the package.json
 * @param dependencyManager {DependencyManager} The dependency manager to use to install the dependencies.
 * @param stdout {Writable} Standard output stream.
 * @returns stderr {Writable} Standard error stream.
 */
declare function install(directory: string, dependencyManager: DependencyManager, stdout?: Writable, stderr?: Writable): Promise<void>;

type dependency_DependencyManager = DependencyManager;
declare const dependency_DependencyManager: typeof DependencyManager;
declare const dependency_dependencyManager: typeof dependencyManager;
declare const dependency_dependencyManagerUsedForCreating: typeof dependencyManagerUsedForCreating;
declare const dependency_install: typeof install;
declare namespace dependency {
  export {
    dependency_DependencyManager as DependencyManager,
    dependency_dependencyManager as dependencyManager,
    dependency_dependencyManagerUsedForCreating as dependencyManagerUsedForCreating,
    dependency_install as install,
  };
}

/**
 * Returns the latest available version of an NPM package.
 * @param name {string} The name of the NPM package.
 * @returns A promise to get the latest available version of a package.
 */
declare function latestNpmPackageVersion(name: string): Promise<string>;

declare const version_latestNpmPackageVersion: typeof latestNpmPackageVersion;
declare namespace version {
  export {
    version_latestNpmPackageVersion as latestNpmPackageVersion,
  };
}

declare const username: (platform?: typeof platform) => Promise<string | null>;
/**
 * Returns the platform and architecture.
 * @returns {{platform: string, arch: string}} Returns the current platform and architecture.
 */
declare const platformAndArch: (platform?: typeof platform) => {
    platform: string;
    arch: string;
};

declare const os_username: typeof username;
declare const os_platformAndArch: typeof platformAndArch;
declare namespace os {
  export {
    os_username as username,
    os_platformAndArch as platformAndArch,
  };
}

/**
 * Returns the path to the user's home directory.
 * @returns {string} The path to the user's home directory.
 */
declare function homeDirectory(): string;
/**
 * Returns true if the CLI is running in debug mode.
 * @param env The environment variables from the environment of the current process.
 * @returns true if SHOPIFY_CONFIG is debug
 */
declare function isDebug(env?: NodeJS.ProcessEnv): boolean;
/**
 * Returns true if the environment in which the CLI is running is either
 * a local environment (where dev is present) or a cloud environment (spin).
 * @returns {boolean} True if the CLI is used in a Shopify environment.
 */
declare function isShopify(env?: NodeJS.ProcessEnv): Promise<boolean>;
/**
 * This variable is used when running unit tests to indicate that the CLI's business logic
 * is run as a subject of a unit test. We can use this variable to disable output through
 * the standard streams.
 * @param env The environment variables from the environment of the current process.
 * @returns True if the SHOPIFY_UNIT_TEST environment variable is truthy.
 */
declare function isUnitTest(env?: NodeJS.ProcessEnv): boolean;

declare const local_homeDirectory: typeof homeDirectory;
declare const local_isDebug: typeof isDebug;
declare const local_isShopify: typeof isShopify;
declare const local_isUnitTest: typeof isUnitTest;
declare namespace local {
  export {
    local_homeDirectory as homeDirectory,
    local_isDebug as isDebug,
    local_isShopify as isShopify,
    local_isUnitTest as isUnitTest,
  };
}

/**
 * Enum that represents the environment to use for a given service.
 * @readonly
 * @enum {number}
 */
declare enum Environment {
    Local = "local",
    Production = "production",
    Spin = "spin"
}

/**
 * Returns the environment to be used for the interactions with the partners' CLI API.
 * @param env The environment variables from the environment of the current process.
 */
declare function partners$2(env?: NodeJS.ProcessEnv): Environment;
/**
 * Returns the environment to be used for the interactions with the admin API.
 * @param env The environment variables from the environment of the current process.
 */
declare function shopify$1(env?: NodeJS.ProcessEnv): Environment;
/**
 * Returns the environment to be used for the interactions with identity.
 * @param env The environment variables from the environment of the current process.
 */
declare function identity$1(env?: NodeJS.ProcessEnv): Environment;

declare namespace service {
  export {
    partners$2 as partners,
    shopify$1 as shopify,
    identity$1 as identity,
  };
}

declare const CouldntObtainPartnersSpinFQDNError: Abort;
declare const CouldntObtainIdentitySpinFQDNError: Abort;
declare const CouldntObtainShopifySpinFQDNError: Abort;
declare const NotProvidedStoreFQDNError: Abort;
/**
 * It returns the Partners' API service we should interact with.
 * @returns {string} Fully-qualified domain of the partners service we should interact with.
 */
declare function partners$1(): Promise<string>;
/**
 * It returns the Identity service we should interact with.
 * @returns {string} Fully-qualified domain of the Identity service we should interact with.
 */
declare function identity(): Promise<string>;
/**
 * It returns the Shopify service we should interact with.
 * Note the same fqdn is sued for the Admin and the Storefront Renderer APIs.
 * @returns {string} Fully-qualified domain of the Shopify service we should interact with.
 */
declare function shopify(options?: {
    storeFqdn?: string;
}): Promise<string>;

declare const fqdn_CouldntObtainPartnersSpinFQDNError: typeof CouldntObtainPartnersSpinFQDNError;
declare const fqdn_CouldntObtainIdentitySpinFQDNError: typeof CouldntObtainIdentitySpinFQDNError;
declare const fqdn_CouldntObtainShopifySpinFQDNError: typeof CouldntObtainShopifySpinFQDNError;
declare const fqdn_NotProvidedStoreFQDNError: typeof NotProvidedStoreFQDNError;
declare const fqdn_identity: typeof identity;
declare const fqdn_shopify: typeof shopify;
declare namespace fqdn {
  export {
    fqdn_CouldntObtainPartnersSpinFQDNError as CouldntObtainPartnersSpinFQDNError,
    fqdn_CouldntObtainIdentitySpinFQDNError as CouldntObtainIdentitySpinFQDNError,
    fqdn_CouldntObtainShopifySpinFQDNError as CouldntObtainShopifySpinFQDNError,
    fqdn_NotProvidedStoreFQDNError as NotProvidedStoreFQDNError,
    partners$1 as partners,
    fqdn_identity as identity,
    fqdn_shopify as shopify,
  };
}

/**
 * Returns whether an environment variable value represents a truthy value.
 * @param variable {string | undefined} Given a environment variable value, it returns true if it represents a truthy value.
 * @returns {boolean}
 */
declare function isTruthy(variable: string | undefined): boolean;

declare const utilities_isTruthy: typeof isTruthy;
declare namespace utilities {
  export {
    utilities_isTruthy as isTruthy,
  };
}

declare const environment_local: typeof local;
declare const environment_service: typeof service;
declare const environment_fqdn: typeof fqdn;
declare const environment_utilities: typeof utilities;
declare namespace environment {
  export {
    environment_local as local,
    environment_service as service,
    environment_fqdn as fqdn,
    environment_utilities as utilities,
  };
}

/**
 * A scope supported by the Shopify Admin API.
 */
declare type AdminAPIScope = 'graphql' | 'themes' | 'collaborator' | string;
/**
 * It represents the options to authenticate against the Shopify Admin API.
 */
interface AdminAPIOAuthOptions {
    /** Store to request permissions for */
    storeFqdn: string;
    /** List of scopes to request permissions for */
    scopes: AdminAPIScope[];
}
/**
 * A scope supported by the Partners API.
 */
declare type PartnersAPIScope = 'cli' | string;
interface PartnersAPIOAuthOptions {
    /** List of scopes to request permissions for */
    scopes: PartnersAPIScope[];
}
/**
 * A scope supported by the Storefront Renderer API.
 */
declare type StorefrontRendererScope = 'devtools' | string;
interface StorefrontRendererAPIOAuthOptions {
    /** List of scopes to request permissions for */
    scopes: StorefrontRendererScope[];
}
/**
 * It represents the authentication requirements and
 * is the input necessary to trigger the authentication
 * flow.
 */
interface OAuthApplications {
    adminApi?: AdminAPIOAuthOptions;
    storefrontRendererApi?: StorefrontRendererAPIOAuthOptions;
    partnersApi?: PartnersAPIOAuthOptions;
}
interface AdminSession {
    token: string;
    storeFqdn: string;
}
interface OAuthSession {
    admin?: AdminSession;
    partners?: string;
    storefront?: string;
}
/**
 * Ensure that we have a valid session to access the Partners API.
 * If SHOPIFY_CLI_PARTNERS_TOKEN exists, that token will be used to obtain a valid Partners Token
 * If SHOPIFY_CLI_PARTNERS_TOKEN exists, scopes will be ignored
 * @param scopes {string[]} Optional array of extra scopes to authenticate with.
 * @returns {Promise<string>} The access token for the Partners API.
 */
declare function ensureAuthenticatedPartners(scopes?: string[], env?: NodeJS.ProcessEnv): Promise<string>;
/**
 * Ensure that we have a valid session to access the Storefront API.
 * @param scopes {string[]} Optional array of extra scopes to authenticate with.
 * @returns {Promise<string>} The access token for the Storefront API.
 */
declare function ensureAuthenticatedStorefront(scopes?: string[]): Promise<string>;
/**
 * Ensure that we have a valid Admin session for the given store.
 * @param store {string} Store fqdn to request auth for
 * @param scopes {string[]} Optional array of extra scopes to authenticate with.
 * @returns {Promise<string>} The access token for the Admin API
 */
declare function ensureAuthenticatedAdmin(store: string, scopes?: string[]): Promise<AdminSession>;
/**
 * This method ensures that we have a valid session to authenticate against the given applications using the provided scopes.
 * @param applications {OAuthApplications} An object containing the applications we need to be authenticated with.
 * @returns {OAuthSession} An instance with the access tokens organized by application.
 */
declare function ensureAuthenticated(applications: OAuthApplications, env?: NodeJS.ProcessEnv): Promise<OAuthSession>;

type session_OAuthApplications = OAuthApplications;
type session_AdminSession = AdminSession;
type session_OAuthSession = OAuthSession;
declare const session_ensureAuthenticatedPartners: typeof ensureAuthenticatedPartners;
declare const session_ensureAuthenticatedStorefront: typeof ensureAuthenticatedStorefront;
declare const session_ensureAuthenticatedAdmin: typeof ensureAuthenticatedAdmin;
declare const session_ensureAuthenticated: typeof ensureAuthenticated;
declare namespace session {
  export {
    session_OAuthApplications as OAuthApplications,
    session_AdminSession as AdminSession,
    session_OAuthSession as OAuthSession,
    session_ensureAuthenticatedPartners as ensureAuthenticatedPartners,
    session_ensureAuthenticatedStorefront as ensureAuthenticatedStorefront,
    session_ensureAuthenticatedAdmin as ensureAuthenticatedAdmin,
    session_ensureAuthenticated as ensureAuthenticated,
  };
}

declare namespace schema {
  export {
    z as define,
  };
}

declare function decode$1(input: string): object;
declare function encode$1(content: any): string;

declare namespace toml {
  export {
    decode$1 as decode,
    encode$1 as encode,
  };
}

declare function decode(input: string): any;
declare function encode(content: any): string;

declare const yaml_decode: typeof decode;
declare const yaml_encode: typeof encode;
declare namespace yaml {
  export {
    yaml_decode as decode,
    yaml_encode as encode,
  };
}

interface CreateOptions {
    port: number;
    authToken: string;
}
declare function create(options: CreateOptions): Promise<string>;

declare const tunnel_create: typeof create;
declare namespace tunnel {
  export {
    tunnel_create as create,
  };
}

interface CachedAppInfo {
    appId: string;
    orgId?: string;
    storeFqdn?: string;
}
interface ConfSchema {
    appInfo: CachedAppInfo[];
    themeStore: string;
}
declare const cliKit: Conf<ConfSchema>;
declare function getAppInfo(appId: string): CachedAppInfo | undefined;
declare function setAppInfo(appId: string, data: {
    storeFqdn?: string;
    orgId?: string;
}): void;
declare function clearAppInfo(appId: string): void;
declare function getThemeStore(): string | undefined;
declare function setThemeStore(store: string): void;

type store_CachedAppInfo = CachedAppInfo;
declare const store_cliKit: typeof cliKit;
declare const store_getAppInfo: typeof getAppInfo;
declare const store_setAppInfo: typeof setAppInfo;
declare const store_clearAppInfo: typeof clearAppInfo;
declare const store_getThemeStore: typeof getThemeStore;
declare const store_setThemeStore: typeof setThemeStore;
declare namespace store {
  export {
    store_CachedAppInfo as CachedAppInfo,
    store_cliKit as cliKit,
    store_getAppInfo as getAppInfo,
    store_setAppInfo as setAppInfo,
    store_clearAppInfo as clearAppInfo,
    store_getThemeStore as getThemeStore,
    store_setThemeStore as setThemeStore,
  };
}

declare function request$1<T>(query: any, session: AdminSession, variables?: any): Promise<T>;

declare namespace admin {
  export {
    request$1 as request,
  };
}

declare function request<T>(query: any, token: string, variables?: any): Promise<T>;

declare const partners_request: typeof request;
declare namespace partners {
  export {
    partners_request as request,
  };
}

declare const FindOrganizationQuery: string;
interface FindOrganizationQuerySchema {
    organizations: {
        nodes: {
            id: string;
            businessName: string;
            website: string;
            stores: {
                nodes: {
                    shopId: string;
                    link: string;
                    shopDomain: string;
                    shopName: string;
                    transferDisabled: boolean;
                    convertableToPartnerTest: boolean;
                }[];
            };
            apps: {
                nodes: {
                    id: string;
                    title: string;
                    apiKey: string;
                    apiSecretKeys: {
                        secret: string;
                    }[];
                    appType: string;
                }[];
            };
        }[];
    };
}

interface AllOrganizationsQuerySchema {
    organizations: {
        nodes: {
            id: string;
            businessName: string;
            website: string;
        }[];
    };
}
declare const AllOrganizationsQuery: string;

declare const CreateAppQuery: string;
interface CreateAppQueryVariables {
    org: number;
    title: string;
    appUrl: string;
    redir: string[];
    type: string;
}
interface CreateAppQuerySchema {
    appCreate: {
        app: {
            id: string;
            apiKey: string;
            title: string;
            applicationUrl: string;
            redirectUrlWhitelist: string[];
            apiSecretKeys: {
                secret: string;
            }[];
            appType: string;
        };
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const UpdateURLsQuery: string;
interface UpdateURLsQueryVariables {
    apiKey: string;
    appUrl: string;
    redir: string[];
}
interface UpdateURLsQuerySchema {
    appUpdate: {
        userErrors: {
            field: string[];
            message: string;
        }[];
    };
}

declare const index_FindOrganizationQuery: typeof FindOrganizationQuery;
type index_FindOrganizationQuerySchema = FindOrganizationQuerySchema;
type index_AllOrganizationsQuerySchema = AllOrganizationsQuerySchema;
declare const index_AllOrganizationsQuery: typeof AllOrganizationsQuery;
declare const index_CreateAppQuery: typeof CreateAppQuery;
type index_CreateAppQueryVariables = CreateAppQueryVariables;
type index_CreateAppQuerySchema = CreateAppQuerySchema;
declare const index_UpdateURLsQuery: typeof UpdateURLsQuery;
type index_UpdateURLsQueryVariables = UpdateURLsQueryVariables;
type index_UpdateURLsQuerySchema = UpdateURLsQuerySchema;
declare namespace index {
  export {
    index_FindOrganizationQuery as FindOrganizationQuery,
    index_FindOrganizationQuerySchema as FindOrganizationQuerySchema,
    index_AllOrganizationsQuerySchema as AllOrganizationsQuerySchema,
    index_AllOrganizationsQuery as AllOrganizationsQuery,
    index_CreateAppQuery as CreateAppQuery,
    index_CreateAppQueryVariables as CreateAppQueryVariables,
    index_CreateAppQuerySchema as CreateAppQuerySchema,
    index_UpdateURLsQuery as UpdateURLsQuery,
    index_UpdateURLsQueryVariables as UpdateURLsQueryVariables,
    index_UpdateURLsQuerySchema as UpdateURLsQuerySchema,
  };
}

declare const api_admin: typeof admin;
declare const api_partners: typeof partners;
declare namespace api {
  export {
    api_admin as admin,
    api_partners as partners,
    index as graphql,
  };
}

declare type Response = ReturnType<typeof nodeFetch>;
/**
 * An interface that abstracts way node-fetch. When Node has built-in
 * support for "fetch" in the standard library, we can drop the node-fetch
 * dependency from here.
 * Note that we are exposing types from "node-fetch". The reason being is that
 * they are consistent with the Web API so if we drop node-fetch in the future
 * it won't require changes from the callers.
 * @param url {RequestInfo} This defines the resource that you wish to fetch.
 * @param init {RequestInit} An object containing any custom settings that you want to apply to the request
 * @returns A promise that resolves with the response.
 */
declare function fetch(url: RequestInfo, init?: RequestInit): Response;

declare const http_fetch: typeof fetch;
declare namespace http {
  export {
    http_fetch as fetch,
  };
}

declare const InvalidChecksumError: ({ file, expected, got }: {
    file: string;
    expected: string;
    got: string;
}) => Abort;
/**
 * Given a local file and a URL pointing to a remote file representing the MD5 of a local file,
 * it validates the authenticity of the binary using an MD5 checksum.
 * @param options: The file to validate and the URL that points to the file containing the MD5.
 */
declare function validateMD5({ file, md5FileURL }: {
    file: string;
    md5FileURL: string;
}): Promise<void>;

declare const checksum_InvalidChecksumError: typeof InvalidChecksumError;
declare const checksum_validateMD5: typeof validateMD5;
declare namespace checksum {
  export {
    checksum_InvalidChecksumError as InvalidChecksumError,
    checksum_validateMD5 as validateMD5,
  };
}

/**
 * Execute CLI 2.0 commands.
 * Installs a version of RubyCLI as a vendor dependency in a hidden folder in the system.
 * User must have a valid ruby+bundler environment to run any command.
 *
 * @param args {string[]} List of argumets to execute. (ex: ['theme', 'pull'])
 * @param token {string} Token to pass to CLI 2.0, will be set as an environment variable
 */
declare function execCLI(args: string[], adminSession?: AdminSession): Promise<void>;

declare const ruby_execCLI: typeof execCLI;
declare namespace ruby {
  export {
    ruby_execCLI as execCLI,
  };
}

declare const semver_coerce: typeof coerce;
declare namespace semver {
  export {
    semver$1 as Version,
    semver_coerce as coerce,
  };
}

interface JSON {
    [key: string]: JSONValue;
}
declare type JSONValue = string | number | boolean | JSON | JSONValue[];
interface PackageJSON extends JSON {
    name: string;
    author: string;
    dependencies: {
        [key: string]: string;
    };
    devDependencies: {
        [key: string]: string;
    };
    resolutions: {
        [key: string]: string;
    };
    overrides: {
        [key: string]: string;
    };
}
declare function readPackageJSON(directory: string): Promise<PackageJSON>;
declare function writePackageJSON(directory: string, packageJSON: JSON): Promise<void>;
declare function updateAppData(packageJSON: JSON, name: string): Promise<void>;

type npm_PackageJSON = PackageJSON;
declare const npm_readPackageJSON: typeof readPackageJSON;
declare const npm_writePackageJSON: typeof writePackageJSON;
declare const npm_updateAppData: typeof updateAppData;
declare namespace npm {
  export {
    npm_PackageJSON as PackageJSON,
    npm_readPackageJSON as readPackageJSON,
    npm_writePackageJSON as writePackageJSON,
    npm_updateAppData as updateAppData,
  };
}

declare function getRandomPort(): Promise<number>;

declare const port_getRandomPort: typeof getRandomPort;
declare namespace port {
  export {
    port_getRandomPort as getRandomPort,
  };
}

declare const constants: {
    environmentVariables: {
        unitTest: string;
        shopifyConfig: string;
        runAsUser: string;
        partnersEnv: string;
        shopifyEnv: string;
        identityEnv: string;
        spin: string;
        spinInstance: string;
        spinWorkspace: string;
        spinNamespace: string;
        spinHost: string;
        partnersToken: string;
    };
    paths: {
        executables: {
            dev: string;
        };
        directories: {
            cache: {
                path: () => string;
                vendor: {
                    path: () => string;
                    binaries: () => string;
                };
            };
        };
    };
    /**
     * Versions are resolved at build time by Rollup's JSON plugin.
     */
    versions: {
        cliKit: string;
        /**
         * cli-kit can resolve the version of cli and app at build time because
         * the version of both packages is tied. If it wasn't, wen'd need
         * to resolve the version at build time.
         * Check out the linked configuration in .changeset/config.json
         */
        cli: string;
        app: string;
        cliHydrogen: string;
    };
    keychain: {
        service: string;
    };
    session: {
        expirationTimeMarginInMinutes: number;
    };
};

export { api, checksum, constants, dependency, environment, error$1 as error, file, git, github, http, npm, os, output, path, port, ruby, schema, semver, session, store, string, system, template, toml, tunnel, ui, version, yaml };
//# sourceMappingURL=index.d.ts.map
